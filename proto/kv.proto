syntax = "proto3";
package api;
option go_package = "api/proto";

message KeyValue{
  bytes key = 1;
  //First revision number when this key value got created
  int64 create_revision = 2;
  //Last revision number after this key value got updated
  int64 mod_revision = 3;
  //Version of this key (different from revision)
  int64 version = 4;
  bytes value = 5;
  int64 lease = 6;
}

message PutRequest{
  // We use bytes here because KV should support all formats of data, and not limited to String
  bytes key = 1;
  bytes value = 2;
  // Lease(TTL) ID
  int64 lease = 3;
  // If prev_key is set to true, the response will include the previous key-value pair, otherwise no value will be returned
  bool prev_kv = 4;
  //If ignore_value is set to true, value will not be reset.
  bool ignore_value = 5;
  //If ignore_lease is set to true, lease will not be reset.
  bool ignore_lease = 6;
}

message PutResponse {
  ResponseHeader header = 1;
  KeyValue prev_kv = 2;
}

message RangeRequest{
  bytes key = 1;
  optional bytes range_end = 2;
  // if limit == 0, no striction to the number of kvs
  int64 limit = 3;
  // MVCC: we can read a specific version
  int64 revision = 4;
  // only return keys not ignore values
  bool keys_only = 5;
}

message RangeResponse{
  ResponseHeader header = 1;
  repeated KeyValue kvs = 2;
  bool more = 3;
  int64 count = 4;
}

message WatchRequest{
  oneof request_union{
    WatchCreateRequest create_request = 1;
    WatchCancelRequest cancel_request = 2;
  }
}

message WatchCreateRequest{
  bytes key = 1;
  bytes range_end = 2;
  //if start_revision == 0, it means we will watch from next revision
  //if start_revision > 0, it means we will watch from a specific revision
  int64 start_revision = 3;
  bool prev_kv = 4;
}

message WatchCancelRequest{
  string watch_id = 1;
}

message WatchResponse{
  ResponseHeader header = 1;
  string watch_id = 2;
  bool created = 3;
  bool canceled = 4;
  repeated Event events = 5;
}

message DeleteRequest{
  bytes key = 1;
  bytes range_end = 2;
  // if prev_key is true, etcd gets the previous key-value pairs before deleting it
  bool prev_key = 3;
}

message DeleteResponse{
  ResponseHeader header = 1;
  // number of keys deleted by the delete range request
  int64 deleted = 2;
  // if prev_key is set in the DeleteRequest, the previous key-value pairs will be returned
  repeated KeyValue prev_kvs = 3;
}

message Event{
  enum EventType{
    PUT = 0;
    DELETE = 1;
  }
  EventType type = 1;
  KeyValue kv = 2;
  KeyValue prev_kv = 3;
}

message ResponseHeader{
  uint64 cluster_id = 1;
  uint64 member_id = 2;
  //All the operations will increment this revision number
  int64 revision = 3;
  uint64 raft_term = 4;
}

message Snapshot{
  int64 revision = 1;
  int64 created_at = 2;
  repeated KeyValue kvs = 3;
}